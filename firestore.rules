/**
 * Core Philosophy:
 * This ruleset implements a role-based access control (RBAC) model combined with
 * user ownership. There are three primary levels of access:
 * 1. Admins: Have global read and write permissions across all data. Admin status
 *    is determined by the existence of a document in the `/roles_admin` collection.
 * 2. Bar Owners: Users designated as the `ownerUserId` on a `/bars/{barId}` document
 *    have full control over that bar and all of its nested data, including products
 *    and inventory sessions.
 * 3. Authenticated Users: Can manage their own user profile in `/users/{userId}`
 *    and can create new bars, which they will then own.
 *
 * Data Structure:
 * The data is structured hierarchically to facilitate clear security boundaries.
 * - `/users/{userId}`: Stores private user profiles, secured by user ID.
 * - `/roles_admin/{userId}`: A simple collection used for fast, efficient checks of
 *   admin privileges.
 * - `/bars/{barId}`: A top-level collection for all business data. Bar documents
 *   are public to read, but all nested subcollections (products, inventory) are
 *   private to the bar owner and admins.
 *
 * Key Security Decisions:
 * - Admin Role Management: The `/roles_admin` collection is read-only from the
 *   client to prevent privilege escalation. It must be managed by a trusted
 *   backend process or manually in the Firebase console.
 * - No User Listing: To protect user privacy, listing the entire `/users` collection
 *   is explicitly disallowed.
 * - Bar Subcollection Privacy: While basic bar info is public, all sensitive sub-data
 *   (like inventory sessions and products) is private to the bar's owner and admins.
 *   This is enforced using a `get()` call on the parent bar document to check ownership.
 *
 * Denormalization for Authorization:
 * To ensure performant and secure rules, authorization relies on denormalized
 * owner IDs. Each `/bars/{barId}` document contains an `ownerUserId`, which is the
 * single source of truth for all write access to that bar and its subcollections.
 * This avoids complex and slow cross-collection queries in the rules. Relational
 * integrity fields (e.g., `barId` on a Product) are validated on write operations
 * to ensure data consistency.
 *
 * Structural Segregation:
 * User-private data (`/users`) is structurally separate from the collaborative
 * business data (`/bars`), allowing for distinct and simple security models for each.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the current user has admin privileges.
     * Admin status is granted by the existence of a document in the /roles_admin collection.
     */
    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Checks if the currently authenticated user's ID matches the provided userId.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * Checks if the document being written to already exists.
     * Crucial for protecting update and delete operations.
     */
    function resourceExists() {
      return resource != null;
    }

    /**
     * Checks if the requesting user is the owner of a specific bar.
     * This requires reading the bar document itself to check the `ownerUserId` field.
     */
    function isBarOwner(barId) {
      return get(/databases/$(database)/documents/bars/$(barId)).data.ownerUserId == request.auth.uid;
    }

    // ------------------------------------------------------------------------
    // Authorization Logic Functions
    // ------------------------------------------------------------------------
    
    /**
     * Determines if a user can read sensitive data within a specific bar's subcollections.
     * Access is granted to the bar owner or an admin.
     */
    function canReadBarData(barId) {
      return isBarOwner(barId) || isAdmin();
    }

    /**
     * Determines if a user can write sensitive data within a specific bar's subcollections.
     * Access is granted to the bar owner or an admin.
     */
    function canWriteBarData(barId) {
      return isBarOwner(barId) || isAdmin();
    }


    // ------------------------------------------------------------------------
    // Data Validation Functions (Prototyping Mode: Authorization-critical fields only)
    // ------------------------------------------------------------------------

    /**
     * On create, validates the user is creating their own profile and setting the ID correctly.
     */
    function isCreatingOwnUser(userId) {
      return isOwner(userId) && request.resource.data.id == userId;
    }

    /**
     * On update, ensures the user's unique ID remains immutable.
     */
    function isUserUpdateValid() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * On create, validates the user is setting themselves as the owner of the new bar.
     */
    function isCreatingOwnBar() {
      return request.resource.data.ownerUserId == request.auth.uid;
    }

    /**
     * On update, ensures the bar's owner ID is immutable.
     */
    function isBarUpdateValid() {
      return request.resource.data.ownerUserId == resource.data.ownerUserId;
    }

    /**
     * On create, validates the product is linked to the correct parent bar via its path.
     */
    function isProductCreateValid(barId) {
      return request.resource.data.barId == barId;
    }
    
    /**
     * On update, ensures the product's link to its parent bar is immutable.
     */
    function isProductUpdateValid() {
      return request.resource.data.barId == resource.data.barId;
    }
    
    /**
     * On create, validates the session is linked to the correct bar and created by the current user.
     */
    function isInventorySessionCreateValid(barId) {
      return request.resource.data.barId == barId && request.resource.data.createdByUserId == request.auth.uid;
    }
    
    /**
     * On update, ensures the session's link to its bar and creator are immutable.
     */
    function isInventorySessionUpdateValid() {
      return request.resource.data.barId == resource.data.barId && request.resource.data.createdByUserId == resource.data.createdByUserId;
    }

    /**
     * On create, validates the line item is linked to the correct parent session.
     */
    function isInventoryLineCreateValid(inventorySessionId) {
      return request.resource.data.inventorySessionId == inventorySessionId;
    }

    /**
     * On update, ensures the line item's link to its parent session is immutable.
     */
    function isInventoryLineUpdateValid() {
      return request.resource.data.inventorySessionId == resource.data.inventorySessionId;
    }

    /**
     * @description Controls access to the admin role collection.
     * This collection is used as a fast lookup to grant admin privileges.
     * It should only be modified by a trusted server environment.
     * @path /roles_admin/{userId}
     * @allow (get) An admin checks if another user is also an admin: `get /roles_admin/other_admin_uid` (auth: admin)
     * @deny (create) A regular user tries to make themselves an admin: `create /roles_admin/user_uid` (auth: non-admin)
     * @deny (list) Anyone tries to list all admins: `list /roles_admin`
     * @principle Prevents client-side privilege escalation.
     */
    match /roles_admin/{userId} {
      allow get: if isAdmin();
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secures user profile documents.
     * Each user has a document in this collection that only they or an admin can access.
     * @path /users/{userId}
     * @allow (create) A new user signs up and creates their own profile: `create /users/user_abc` (auth: user_abc)
     * @allow (get) An admin views a user's profile: `get /users/user_abc` (auth: admin)
     * @deny (get) A user tries to read another user's profile: `get /users/user_xyz` (auth: user_abc)
     * @deny (list) Anyone tries to get a list of all users.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if false;
      allow create: if isCreatingOwnUser(userId);
      allow update: if isOwner(userId) && resourceExists() && isUserUpdateValid();
      allow delete: if (isOwner(userId) || isAdmin()) && resourceExists();
    }

    /**
     * @description Secures the top-level bar documents.
     * Bar information is public to read, but only the owner or an admin can modify it.
     * This collection is the root for all bar-specific data.
     * @path /bars/{barId}
     * @allow (get) Any user, signed in or not, can view a bar's details: `get /bars/bar_123`
     * @allow (create) An authenticated user creates a new bar they will own: `create /bars/bar_123` (auth: user_abc, data: {ownerUserId: 'user_abc'})
     * @deny (update) A user tries to modify a bar they don't own: `update /bars/bar_123` (auth: user_xyz)
     * @principle Implements public read with owner-only writes.
     */
    match /bars/{barId} {
      allow get, list: if true;
      allow create: if isSignedIn() && isCreatingOwnBar();
      allow update: if (isOwner(resource.data.ownerUserId) || isAdmin()) && resourceExists() && isBarUpdateValid();
      allow delete: if (isOwner(resource.data.ownerUserId) || isAdmin()) && resourceExists();

      /**
       * @description Secures product information for a specific bar.
       * Only the owner of the parent bar or an admin can read or write product data.
       * @path /bars/{barId}/products/{productId}
       * @allow (get, list) The bar owner views their products: `list /bars/bar_123/products` (auth: bar owner)
       * @deny (get) A regular user tries to view products for a bar: `get /bars/bar_123/products/prod_456` (auth: user_xyz)
       * @deny (create) A user tries to add a product to a bar they don't own.
       * @principle Enforces hierarchical security based on the parent document's ownership.
       */
      match /products/{productId} {
        allow get, list: if canReadBarData(barId);
        allow create: if canWriteBarData(barId) && isProductCreateValid(barId);
        allow update: if canWriteBarData(barId) && resourceExists() && isProductUpdateValid();
        allow delete: if canWriteBarData(barId) && resourceExists();
      }

      /**
       * @description Secures inventory session data for a bar.
       * Access is restricted to the owner of the parent bar or an admin.
       * @path /bars/{barId}/inventorySessions/{inventorySessionId}
       * @allow (get, list) The bar owner lists their inventory sessions: `list /bars/bar_123/inventorySessions` (auth: bar owner)
       * @deny (create) A regular user tries to start an inventory session for a bar they do not own.
       * @principle Enforces hierarchical security based on the parent document's ownership.
       */
      match /inventorySessions/{inventorySessionId} {
        allow get, list: if canReadBarData(barId);
        allow create: if canWriteBarData(barId) && isInventorySessionCreateValid(barId);
        allow update: if canWriteBarData(barId) && resourceExists() && isInventorySessionUpdateValid();
        allow delete: if canWriteBarData(barId) && resourceExists();

        /**
         * @description Secures individual line items within an inventory session.
         * Access is inherited from the grandparent bar document's ownership.
         * @path /bars/{barId}/inventorySessions/{inventorySessionId}/lines/{inventoryLineId}
         * @allow (update) The bar owner updates a line item count: `update /bars/bar_123/inventorySessions/sess_abc/lines/line_xyz` (auth: bar owner)
         * @deny (get) A regular user attempts to read inventory line item data.
         * @principle Enforces deep hierarchical security based on a top-level ancestor's ownership.
         */
        match /lines/{inventoryLineId} {
          allow get, list: if canReadBarData(barId);
          allow create: if canWriteBarData(barId) && isInventoryLineCreateValid(inventorySessionId);
          allow update: if canWriteBarData(barId) && resourceExists() && isInventoryLineUpdateValid();
          allow delete: if canWriteBarData(barId) && resourceExists();
        }
      }
    }
  }
}